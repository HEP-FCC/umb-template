general {
    # Logging level - can be DEBUG, INFO, WARNING, ERROR, CRITICAL
    log_level = "INFO"
    log_level = ${?METADATA_BROWSER_LOG_LEVEL}

    # CERN OAuth client configuration (optional secrets - only required when auth is enabled)
    cern_client_id = ${?METADATA_BROWSER_CERN_CLIENT_ID}
    cern_client_secret = ${?METADATA_BROWSER_CERN_CLIENT_SECRET}

    # Application security key - required for session cookie JWT encryption
    application_secret_key = ${METADATA_BROWSER_APPLICATION_SECRET_KEY}

    # Security settings
    https_only = "false"
    https_only = ${?METADATA_BROWSER_HTTPS_ONLY}

    # CERN OAuth redirect URI
    cern_redirect_uri = "http://localhost:8000/auth"
    cern_redirect_uri = ${?METADATA_BROWSER_CERN_REDIRECT_URI}

    # Frontend URL for CORS and redirects
    frontend_url = "http://localhost:3000"
    frontend_url = ${?METADATA_BROWSER_FRONTEND_URL}

    # Cookie prefix for session management
    cookie_prefix = "universal-metadata-browser"
    cookie_prefix = ${?METADATA_BROWSER_COOKIE_PREFIX}
}

# Application configuration
application {
    # The main entity table name (source of truth for all data)
    # This table should contain foreign keys to all navigation entities
    main_table = "entities"
    main_table = ${?METADATA_BROWSER_MAIN_TABLE}

    # Application branding
    title = "Universal Metadata Browser"
    title = ${?METADATA_BROWSER_TITLE}

    description = "Search and explore your metadata catalog"
    description = ${?METADATA_BROWSER_DESCRIPTION}

    search_placeholder = "Search entities..."
    search_placeholder = ${?METADATA_BROWSER_SEARCH_PLACEHOLDER}

    # API configuration
    timeout = 30
    timeout = ${?METADATA_BROWSER_TIMEOUT}

    max_page_size = 1000
    max_page_size = ${?METADATA_BROWSER_MAX_PAGE_SIZE}

    default_page_size = 25
    default_page_size = ${?METADATA_BROWSER_DEFAULT_PAGE_SIZE}

    # Database pool configuration
    pool_min_size = 5
    pool_min_size = ${?METADATA_BROWSER_POOL_MIN_SIZE}

    pool_max_size = 20
    pool_max_size = ${?METADATA_BROWSER_POOL_MAX_SIZE}

    # Batch processing configuration
    batch_size = 128
    batch_size = ${?METADATA_BROWSER_BATCH_SIZE}

    # TODO: For now there is just "name" allowed other value will not work
    entity_name_field = "name"
}

# File watcher configuration
file_watcher {
    # Enable or disable the file watcher service
    enabled = true
    enabled = ${?METADATA_BROWSER_FILE_WATCHER_ENABLED}

    # List of directories to watch for changes (absolute paths)
    watch_paths = ["/data"]
    watch_paths = ${?METADATA_BROWSER_FILE_WATCHER_PATHS}

    # File extensions to monitor (e.g., [".json", ".txt"])
    file_extensions = [".json"]
    file_extensions = ${?METADATA_BROWSER_FILE_WATCHER_EXTENSIONS}

    # Watch subdirectories recursively
    recursive = true
    recursive = ${?METADATA_BROWSER_FILE_WATCHER_RECURSIVE}

    # Debounce delay in seconds to wait after file change before processing
    # This helps ensure the file is fully written before processing
    debounce_delay = 2
    debounce_delay = ${?METADATA_BROWSER_FILE_WATCHER_DEBOUNCE_DELAY}

    # Polling interval in seconds for checking file changes
    polling_interval = 300
    polling_interval = ${?METADATA_BROWSER_FILE_WATCHER_POLLING_INTERVAL}

    # Startup behavior: how to handle existing files when the service starts
    # Options:
    # - "ignore": Only process files that change after startup (recommended for production)
    # - "process_all": Process all existing files on startup (useful for initial data load)
    # - "process_new": Only process files newer than the last service run
    startup_mode = "process_all"
    startup_mode = ${?METADATA_BROWSER_STARTUP_MODE}

    # State file to track processed files (for persistent state across restarts)
    # If not specified, state is only kept in memory
    state_file = "/app/locks/file_watcher_state.json"
    state_file = ${?METADATA_BROWSER_STATE_FILE}

    # Lock file for worker coordination (should be on shared storage for multiple workers)
    # This ensures only one worker handles file watching across all replicas
    lock_file = "/backend-storage/file_watcher.lock"
    lock_file = ${?METADATA_BROWSER_FILE_WATCHER_LOCK_FILE}
}

# Navigation configuration
# Defines the order of navigation entities (determines display order in frontend)
# NOTE: These must match the foreign key column names in the main table (without _id suffix)
navigation {
    order = ["category", "type", "source", "status", "format"]
}

auth {
    # Enable or disable authentication (default: false for easy template setup)
    # When disabled, all endpoints work without authentication
    enabled = false
    enabled = ${?METADATA_BROWSER_AUTH_ENABLED}

    # Token cache duration in seconds
    cache_duration = 3600
    cache_duration = ${?METADATA_BROWSER_AUTH_CACHE_DURATION}

    # Minimum token length for validation
    min_token_length = 10
    min_token_length = ${?METADATA_BROWSER_AUTH_MIN_TOKEN_LENGTH}

    # OpenID connect configuration URL
    auth_oidc_url = ${?METADATA_BROWSER_AUTH_OIDC_URL}

    # Auth OpenID issuer URL
    auth_issuer = ${?METADATA_BROWSER_AUTH_ISSUER}

    # Required CERN role for authentication (optional - if not set, no role check)
    required_cern_role = ${?METADATA_BROWSER_REQUIRED_CERN_ROLE}

    # Endpoint-specific role requirements
    # Configure required roles for each authenticated endpoint
    # These can be overridden using environment variables
    endpoints {
        # Entity management endpoints
        update_entity = "authorized"
        update_entity = ${?METADATA_BROWSER_REQUIRED_ROLE_ENDPOINT_UPDATE_ENTITY}

        update_metadata_lock = "authorized"
        update_metadata_lock = ${?METADATA_BROWSER_REQUIRED_ROLE_ENDPOINT_UPDATE_METADATA_LOCK}

        delete_entities = "authorized"
        delete_entities = ${?METADATA_BROWSER_REQUIRED_ROLE_ENDPOINT_DELETE_ENTITIES}

        override_entities = "authorized"
        override_entities = ${?METADATA_BROWSER_REQUIRED_ROLE_ENDPOINT_OVERRIDE_ENTITIES}
    }
}

database {
    # Database connection configuration (required)
    host = ${METADATA_BROWSER_POSTGRES_HOST}
    port = ${METADATA_BROWSER_POSTGRES_PORT}

    user = ${METADATA_BROWSER_POSTGRES_USER}
    password = ${METADATA_BROWSER_POSTGRES_PASSWORD}

    db = ${METADATA_BROWSER_POSTGRES_DB}

    # Optional database schema file path
    schema_file = ${?METADATA_BROWSER_DATABASE_SCHEMA_FILE}

    # Advisory lock ID for schema migrations (ensures only one process applies schema changes)
    # This PostgreSQL advisory lock prevents concurrent schema application from multiple workers
    schema_advisory_lock_id = 1234567890
    schema_advisory_lock_id = ${?METADATA_BROWSER_SCHEMA_ADVISORY_LOCK_ID}

    # UUID namespace for entity identification - creates deterministic UUIDs for entities
    # This namespace is version-specific (v01) and ensures consistent UUID generation
    # Format: "entity_uuid_namespace.{version}" where version changes for breaking schema changes
    entity_uuid_namespace = "entity_uuid_namespace.v01"
    entity_uuid_namespace = ${?METADATA_BROWSER_ENTITY_UUID_NAMESPACE}
}
